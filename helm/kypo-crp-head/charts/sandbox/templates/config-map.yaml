apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Values.global.services.sandbox.name }}-configmap
data:
  config.yml: |
    # Name of the microservice.
    #microservice_name: kypo-sandbox-service

    # A prefix of the stack in the cloud with maximum 8 characters.
    stack_name_prefix: {{ .Values.kypoCrpInstanceName }}

    # A boolean that turns on/off debug mode.
    # SECURITY WARNING: don't run with debug turned on in production!
    debug: False

    # A list of strings representing the host/domain names that this Django site can serve.
    #allowed_hosts: []

    # If True, the whitelist will not be used and all origins will be accepted.
    cors_origin_allow_all: False

    # A list of origins that are authorized to make cross-site HTTP requests.
    cors_origin_whitelist: ["https://{{ .Values.global.kypoCrpHost }}"]

    authentication:
        # Whether the REST API authentication is on.
        # If set to False, other authentication variables are not used.
        authenticated_rest_api: True

        # List of OIDC provider host/domain names that are allowed.
        allowed_oidc_providers:
    {{- range .Values.global.kypoCrpOidcs }}
              - issuer: {{ trimSuffix "/" .url }}
                userinfo_endpoint:
    {{- end }}
        # User and Group roles registration endpoint URL.
        roles_registration_url: "http://{{ .Values.global.services.userAndGroup.name }}:{{ .Values.global.services.userAndGroup.port }}{{ .Values.global.services.userAndGroup.contextPath }}microservices"

        # User and Group roles acquisition endpoint URL.
        roles_acquisition_url: "http://{{ .Values.global.services.userAndGroup.name }}:{{ .Values.global.services.userAndGroup.port }}{{ .Values.global.services.userAndGroup.contextPath }}users/info"

    application_configuration:
        # The IP address of the KYPO head server.
        kypo_head_ip: {{ .Values.kypoCrpHeadIp }}

        # The URL of OpenStack Identity service API.
        os_auth_url: {{ .Values.kypoCrpOsAuthUrl }}

        # The ID of application credentials to authenticate at OpenStack cloud platform.
        os_application_credential_id: {{ .Values.kypoCrpOsApplicationCredentialId }}

        # The secret string of APPLICATION_CREDENTIAL_ID.
        os_application_credential_secret: {{ .Values.kypoCrpOsApplicationCredentialSecret }}

        # The OpenStack console type. One of: novnc, xvpvnc, spice-html5, rdp-html5, serial, webmks.
        os_console_type: {{ .Values.kypoCrpOsConsoleType }}

        # The path to project log file.
        #log_file: kypo-sandbox-service.log

        # The level of log verbosity. One of: NOTSET, DEBUG, INFO, WARNING, ERROR, FATAL, CRITICAL.
        #log_level: INFO

        # The type of Git repositories. One of: INTERNAL, GITLAB.
        git_type: {{ .Values.kypoCrpGit.type }}

        # Git server hostname or IP.
        git_server: {{ .Values.kypoCrpGit.server }}

        # Git server ssh port
        git_ssh_port: {{ .Values.kypoCrpGit.sshPort }}

        # The address of Git REST server with protocol (optionally port)
        git_rest_server: {{ .Values.kypoCrpGit.restServerUrl }}

        # The name of user used for communication with Git repository.
        git_user: {{ .Values.kypoCrpGit.user }}

        # The SSH private key that kypo2-django-openstack uses to communicate with Git repository.
        git_private_key: /root/.ssh/git-ssh-key

        # The access token for Gitlab API
        git_access_token: {{ .Values.kypoCrpGit.accessToken }}

        # The URL of Ansible networking Git repository.
        ansible_networking_url: {{ .Values.kypoCrpGit.ansibleNetworkingUrl }}

        # The rev of Ansible networking Git repository.
        ansible_networking_rev: {{ .Values.kypoCrpGit.ansibleNetworkingRev }}

        # The pattern to be replaced in image names of sandbox definitions.
        image_naming_strategy:
            pattern: ^munikypo/
            replace: ''

        #The mapping of flavor names to be replaced in sandbox definition.
        #flavor_mapping: {}

        # The object that represents SSH Host entry (see man page of ssh_config).
        proxy_jump_to_man:
            Host: {{ .Values.kypoCrpProxyHost }}
            User: {{ .Values.kypoCrpProxyUser }}
            IdentityFile: /root/.ssh/kypo-crp-proxy-key

        # Timeout of sandbox (stack) creation in cloud in seconds.
        sandbox_build_timeout: {{ .Values.kypoSandboxBuildTimeout }}

        # Timeout of sandbox (stack) deletion in cloud in seconds.
        sandbox_delete_timeout: {{ .Values.kypoSandboxDeleteTimeout }}

        # Timeout for Ansible.
        sandbox_ansible_timeout: {{ .Values.kypoSandboxAnsibleTimeout }}

        # The path to local temporary directory where KYPO will prepare Docker volumes.
        ansible_docker_volumes: /var/opt/kypo/kypo-ansible-runner-volumes

        # The name of the Docker image that is able to run Ansible playbook.
        ansible_docker_image: {{ .Values.ansibleRunner.image.url }}:{{ .Values.ansibleRunner.image.tag }}

        # Answers storage base URL.
        answers_storage_api: http://{{ .Values.global.services.answersStorage.name }}:{{ .Values.global.services.answersStorage.port }}{{ .Values.global.services.answersStorage.contextPath }}

        # The name of the Docker network that the Runner will use.
        ansible_docker_network: {{ .Values.ansibleDockerNetwork }}

        # A path to directory of CA certificates or file of CA certificates, i.e. CA bundle.
        # Use in case of self-signed certificates in related services.
        ssl_ca_certificate_verify: /etc/ssl/certs/ca-certificates.crt

        sandbox_configuration:
            # The name or ID of network in OpenStack where all sandboxes will be deployed.
            base_network: kypo-base-net

            # The name of the image in OpenStack that will be used for MAN.
            man_image: "debian-9-x86_64"

            # The name of user in MAN.
            man_user: "debian"

            # The name of the flavor in OpenStack that will be used for MAN.
            man_flavor: "{{ .Values.kypoManFlavor }}"

            # The cidr notation of network between MAN and every other node in sandbox.
            #sb_man_cidr: 192.168.128.0/17

            # The list of IP addresses to custom DNS servers.
            dns_name_servers: [{{ join "," .Values.kypoCrpDns }}]

        # Django database settings.
        database:
            # The database backend to use.
            engine: "django.db.backends.postgresql"

            # Which host to use when connecting to the database.
            host: {{ .Values.global.postgres.dns }}

            # The port to use when connecting to the database.
            port: "{{ .Values.global.postgres.port }}"

            # The name of the database to use.
            name: {{ .Values.global.postgresServices.sandbox.dbName }}

            # The password to use when connecting to the database.
            password: {{ .Values.global.postgresServices.sandbox.dbPassword }}

            # The username to use when connecting to the database.
            user: {{ .Values.global.postgresServices.sandbox.dbUser }}

  settings.py: |
    """
    Django settings for kypo.sandbox_service_project project.

    Generated by 'django-admin startproject' using Django 2.2.6.

    For more information on this file, see
    https://docs.djangoproject.com/en/2.2/topics/settings/

    For the full list of settings and their values, see
    https://docs.djangoproject.com/en/2.2/ref/settings/
    """

    import os
    from kypo.sandbox_common_lib.kypo_service_config import KypoServiceConfig

    # Build paths inside the project like this: os.path.join(BASE_DIR, ...)
    BASE_DIR = os.path.dirname(
        os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

    # Quick-start development settings - unsuitable for production
    # See https://docs.djangoproject.com/en/2.2/howto/deployment/checklist/

    KYPO_SANDBOX_SERVICE_CONFIG_PATH = os.path.join(BASE_DIR, 'config.yml')
    KYPO_SERVICE_CONFIG = KypoServiceConfig.from_file(KYPO_SANDBOX_SERVICE_CONFIG_PATH)
    KYPO_CONFIG = KYPO_SERVICE_CONFIG.app_config
    os.environ['REQUESTS_CA_BUNDLE'] = KYPO_CONFIG.ssl_ca_certificate_verify

    # SECURITY WARNING: keep the secret key used in production secret!
    SECRET_KEY = '-^mu0=6s@*x4jdbrz5yr!++p*02#%m$_4&0uw8h1)&r5u!v=12'

    # SECURITY WARNING: don't run with debug turned on in production!
    DEBUG = KYPO_SERVICE_CONFIG.debug

    ALLOWED_HOSTS = tuple(KYPO_SERVICE_CONFIG.allowed_hosts)

    # Application definition

    CORS_ORIGIN_ALLOW_ALL = KYPO_SERVICE_CONFIG.cors_origin_allow_all
    CORS_ORIGIN_WHITELIST = tuple(KYPO_SERVICE_CONFIG.cors_origin_whitelist)

    INSTALLED_APPS = [
        'django.contrib.admin',
        'django.contrib.auth',
        'django.contrib.contenttypes',
        'django.contrib.sessions',
        'django.contrib.messages',
        'django.contrib.staticfiles',
        'rest_framework',
        'drf_yasg2',
        'corsheaders',
        'django_rq',

        'kypo.sandbox_ansible_app.apps.KypoSandboxAnsibleAppConfig',
        'kypo.sandbox_definition_app.apps.KypoSandboxDefinitionAppConfig',
        'kypo.sandbox_instance_app.apps.KypoSandboxInstanceAppConfig',
    ]

    MIDDLEWARE = [
        'corsheaders.middleware.CorsMiddleware',
        'django.middleware.common.CommonMiddleware',
        'django.middleware.security.SecurityMiddleware',
        'django.contrib.sessions.middleware.SessionMiddleware',
        'django.middleware.common.CommonMiddleware',
        'django.middleware.csrf.CsrfViewMiddleware',
        'django.contrib.auth.middleware.AuthenticationMiddleware',
        'django.contrib.messages.middleware.MessageMiddleware',
        'django.middleware.clickjacking.XFrameOptionsMiddleware',
    ]

    ROOT_URLCONF = 'kypo.sandbox_service_project.urls'

    TEMPLATES = [
        {
            'BACKEND': 'django.template.backends.django.DjangoTemplates',
            'DIRS': [],
            'APP_DIRS': True,
            'OPTIONS': {
                'context_processors': [
                    'django.template.context_processors.debug',
                    'django.template.context_processors.request',
                    'django.contrib.auth.context_processors.auth',
                    'django.contrib.messages.context_processors.messages',
                ],
            },
        },
    ]

    WSGI_APPLICATION = 'kypo.sandbox_service_project.wsgi.application'

    # Database
    # https://docs.djangoproject.com/en/2.2/ref/settings/#databases

    DATABASES = {
        'default': {
            'ENGINE': KYPO_CONFIG.database.engine,
            'HOST': KYPO_CONFIG.database.host,
            'NAME': KYPO_CONFIG.database.name,
            'PASSWORD': KYPO_CONFIG.database.password,
            'PORT': KYPO_CONFIG.database.port,
            'USER': KYPO_CONFIG.database.user
        },
    }

    # Password validation
    # https://docs.djangoproject.com/en/2.2/ref/settings/#auth-password-validators

    AUTH_PASSWORD_VALIDATORS = [
        {
            'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
        },
        {
            'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
        },
        {
            'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
        },
        {
            'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
        },
    ]

    # Internationalization
    # https://docs.djangoproject.com/en/2.2/topics/i18n/

    LANGUAGE_CODE = 'en-us'

    TIME_ZONE = 'Europe/Prague'

    USE_I18N = True

    USE_L10N = True

    USE_TZ = True

    # Static files (CSS, JavaScript, Images)
    # https://docs.djangoproject.com/en/2.2/howto/static-files/

    STATIC_ROOT = os.path.join(BASE_DIR, 'static')
    STATIC_URL = f'/{KYPO_SERVICE_CONFIG.microservice_name}/static/'

    REST_FRAMEWORK = {
        'EXCEPTION_HANDLER': 'kypo.sandbox_common_lib.exc_handler.custom_exception_handler',
        'DEFAULT_PERMISSION_CLASSES': ('rest_framework.permissions.AllowAny', ),

        'DEFAULT_PAGINATION_CLASS': 'kypo.sandbox_common_lib.pagination.PageNumberWithPageSizePagination',
        'PAGE_SIZE': 50,
    }

    SWAGGER_SETTINGS = {
        'DEFAULT_PAGINATOR_INSPECTORS': [
            'kypo.sandbox_common_lib.inspectors.PageNumberWithPageSizePaginationInspector',
            'drf_yasg2.inspectors.DjangoRestResponsePagination',
            'drf_yasg2.inspectors.CoreAPICompatInspector',
        ],
    }

    if KYPO_SERVICE_CONFIG.authentication.authenticated_rest_api:
        REST_FRAMEWORK.update({
            'DEFAULT_PERMISSION_CLASSES': (
                'kypo.sandbox_common_lib.permissions.ModelPermissions',
            ),
            'DEFAULT_AUTHENTICATION_CLASSES': (
                # For testing purposes, uncomment BasicAuthentication.
                # It allows login using name & password (nice for permission testing).
                # 'rest_framework.authentication.BasicAuthentication',
                'csirtmu.oidc_client.authentication.JWTAccessTokenAuthentication',
            ),
        })

        OIDC_AUTH = {
            # (Optional) Function that resolves id_token into user.
            # This function receives a request and an id_token dict and expects to
            # return a User object. The default implementation tries to find the user
            # based on username (natural key) taken from the 'sub'-claim of the
            # id_token.
            'OIDC_RESOLVE_USER_FUNCTION': 'csirtmu.uag_auth.auth.get_or_create_user',
        }

        CSIRTMU_OIDC_CLIENT = {
            # Need to be set when using JWTAccessTokenAuthentication,
            # which supports multiple OIDC providers (parsing them from the token).
            # Only those listed here will be allowed.
            'ALLOWED_OIDC_PROVIDERS': tuple(KYPO_SERVICE_CONFIG.authentication.allowed_oidc_providers)
        }

        CSIRTMU_UAG_AUTH = {
            # User and Group roles registration endpoint URL
            'ROLES_REGISTRATION_URL': KYPO_SERVICE_CONFIG.authentication.roles_registration_url,
            # User and Group roles acquisition endpoint URL
            'ROLES_ACQUISITION_URL': KYPO_SERVICE_CONFIG.authentication.roles_acquisition_url,
            # Path to roles definition file
            'ROLES_DEFINITION_PATH': os.path.join(BASE_DIR,
                                                  'kypo/sandbox_service_project/permissions/roles.yml'),

            # User and Group information configuration
            'MICROSERVICE_NAME': KYPO_SERVICE_CONFIG.microservice_name,
            'ROLE_PREFIX': "ROLE",
            'ENDPOINT': __package__,
        }

    CACHES = {
        'default': {
            'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
            'LOCATION': 'call_cache',
            'TIMEOUT': None,  # Expire never
            'OPTIONS': {
                'MAX_ENTRIES': 300  # Django default value is 300 (2 kB per item = 0.6 MB)
            }
        },
        'uag_auth_groups_cache': {
            'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
            'LOCATION': 'uag_auth_groups_cache',
            'OPTIONS': {
                'MAX_ENTRIES': 500
            }
        },
    }

    RQ_QUEUES = {
        'default': {
            'HOST': '{{ .Values.global.kypoRedisServiceName }}',
            'PORT': 6379,
            'DB': 0,
        },
        'openstack': {
            'HOST': '{{ .Values.global.kypoRedisServiceName }}',
            'PORT': 6379,
            'DB': 0,
        },
        'ansible': {
            'HOST': '{{ .Values.global.kypoRedisServiceName }}',
            'PORT': 6379,
            'DB': 0,
        }
    }

    RQ_SHOW_ADMIN_LINK = True
    RQ_EXCEPTION_HANDLERS = ['kypo.sandbox_instance_app.lib.request_handlers.request_exception_handler']

    LOGGING = {
        "version": 1,
        "disable_existing_loggers": False,
        "formatters": {
            "rq_console": {
                'format': '%(asctime)s %(levelname)s %(message)s',
                "datefmt": "%H:%M:%S",
            },
        },
        "handlers": {
            "rq_console": {
                "level": KYPO_CONFIG.log_level,
                "class": "rq.utils.ColorizingStreamHandler",
                "formatter": "rq_console",
                "exclude": ["%(asctime)s"],
            },
        },
        'loggers': {
            "rq.worker": {
                "handlers": ["rq_console"],
                "level": KYPO_CONFIG.log_level,
            },
        }
    }

  stage_handlers.py: |
    import os
    import docker.errors
    import structlog
    import abc
    from typing import Type
    from django.conf import settings
    from django.utils import timezone
    from requests import exceptions as requests_exceptions
    from redis import Redis
    from rq.exceptions import NoSuchJobError
    from rq.job import Job

    from kypo.openstack_driver.exceptions import KypoException

    from kypo.sandbox_ansible_app.lib.ansible import CleanupAnsibleDockerRunner,\
        AllocationAnsibleDockerRunner, AnsibleDockerRunner
    from kypo.sandbox_ansible_app.models import AnsibleAllocationStage, AnsibleCleanupStage,\
        DockerContainer, AllocationAnsibleOutput, CleanupAnsibleOutput, UserAnsibleCleanupStage,\
        CleanupStage, DockerContainerCleanup
    from kypo.sandbox_common_lib import utils, exceptions
    from kypo.sandbox_definition_app.lib import definitions

    from kypo.sandbox_instance_app.models import Sandbox, HeatStack,\
        SandboxAllocationUnit, StackAllocationStage, StackCleanupStage,\
        RQJob, AllocationRQJob, CleanupRQJob

    LOG = structlog.get_logger()


    class StageHandler(abc.ABC):
        """
        Handles DB Stage object and generalizes its common tasks.

        WARNING: Always set _job_class attribute with type inherited from RQJob
          in all non-abstract descendants.
        """
        _job_class: Type[RQJob]

        def __init__(self, stage, name: str = None):
            self.stage = stage
            self.name = name if name is not None else self.stage.__class__.__name__

        def execute(self) -> None:
            """
            Handles stage execution defined in method _execute.

            Sets the start and the end time of the stage execution, saves any error messages
              of all caught exceptions, and re-raise them again.
            Warning: Do not override this method. Any changes should be made to _execute method.
            """
            try:
                LOG.info(f'Stage {self.name} started', stage=self.stage)
                self.stage.start = timezone.now()
                self.stage.save()
                return self._execute()
            except Exception as ex:
                self.stage.failed = True
                self.stage.error_message = str(ex)
                raise
            finally:
                self.stage.end = timezone.now()
                self.stage.finished = True
                self.stage.save()
                LOG.info(f'Stage {self.name} ended', stage=self.stage)

        def set_job_id(self, job_id: str) -> None:
            """
            Set Job ID once execution of this stage is enqueued.

            :param job_id: The ID of enqueues Job that will execute this stage.
            """
            if hasattr(self._job_class, 'allocation_stage'):
                self._job_class.objects.create(allocation_stage=self.stage, job_id=job_id)
            elif hasattr(self._job_class, 'cleanup_stage'):
                self._job_class.objects.create(cleanup_stage=self.stage, job_id=job_id)
            else:
                LOG.warning(f'Unknown Job class \'{self._job_class}\'. Job ID \'{job_id}\' was not set')

        @abc.abstractmethod
        def _execute(self) -> None:
            """
            Execute the stage.
            """
            pass

        def cancel(self) -> None:
            """
            Handles stage cancellation defined in method _cancel.

            Stops the stage execution, sets the stage as failed, sets its end time of execution,
              saves any error messages of caught exceptions during cancellation,
              and re-raise them again.
            Warning: Do not override this method. Any changes should be made to _cancel method.
            """
            if not self.stage.finished:
                try:
                    LOG.info(f'Cancellation of stage {self.name} started', stage=self.stage)
                    self._delete_job()
                    return self._cancel()
                except Exception as ex:
                    self.stage.error_message = str(ex)
                    raise
                finally:
                    self.stage.failed = True
                    self.stage.end = timezone.now()
                    self.stage.finished = True
                    self.stage.save()
                    LOG.info(f'Cancellation of stage {self.name} ended', stage=self.stage)

        def _delete_job(self) -> None:
            """
            Remove and delete enqueued Job of the stage execution from a queue.
            """
            if hasattr(self.stage, 'rq_job'):
                try:
                    Job.fetch(self.stage.rq_job.job_id, connection=Redis(host='{{ .Values.global.kypoRedisServiceName }}'))\
                        .delete(delete_dependents=True)
                except NoSuchJobError:  # Job already deleted
                    pass
            else:
                LOG.warning(f'Stage {self.name} does not have an RQ job')

        @abc.abstractmethod
        def _cancel(self) -> None:
            """
            Cancel the stage
            """
            pass


    class StackStageHandler(StageHandler):
        """
        Generalizes common tasks of stages manipulating with OpenStack stacks.
        """
        _client = utils.get_ostack_client()

        @abc.abstractmethod
        def _execute(self) -> None:
            pass

        @abc.abstractmethod
        def _cancel(self) -> None:
            pass

        def _delete_sandbox(self, allocation_unit: SandboxAllocationUnit) -> None:
            """
            Delete sandbox associated with the given allocation unit
              and wait for its completion if wait parameter is True.
            """
            stack_name = allocation_unit.get_stack_name()

            LOG.debug('Starting Stack delete in OpenStack', stack_name=stack_name,
                      allocation_unit=allocation_unit)

            try:
                self._client.delete_stack(stack_name)
            except KypoException as ex:
                # Sandbox is already deleted.
                LOG.warning('Deleting sandbox failed', exception=str(ex),
                            allocation_unit=allocation_unit)
                return


    class AllocationStackStageHandler(StackStageHandler):
        """
        Specifies tasks needed for OpenStack stack allocation and its cancellation.
        """
        stage: StackAllocationStage
        _job_class: Type[AllocationRQJob] = AllocationRQJob

        def _execute(self) -> None:
            """
            Allocate stack in the OpenStack cloud platform.
            """
            allocation_unit = self.stage.allocation_request.allocation_unit
            pool = allocation_unit.pool
            definition = pool.definition
            top_def = definitions.get_definition(definition.url, pool.rev_sha, settings.KYPO_CONFIG)
            stack = self._client.create_stack(
                allocation_unit.get_stack_name(), top_def,
                key_pair_name_ssh=allocation_unit.pool.ssh_keypair_name,
                key_pair_name_cert=allocation_unit.pool.certificate_keypair_name,
            )

            HeatStack.objects.create(allocation_stage=self.stage, stack_id=stack['stack']['id'])

            self._wait_for_stack_creation()

        def _wait_for_stack_creation(self) -> None:
            """
            Wait for the stack creation.
            """
            name = self.stage.allocation_request.allocation_unit.get_stack_name()
            success, msg = self._client.wait_for_stack_create_action(name)
            if not success:
                roll_succ, roll_msg = self._client.wait_for_stack_rollback_action(name)
                if not roll_succ:
                    LOG.warning('Rollback failed', msg=roll_msg)
                raise exceptions.StackError(f'Sandbox build failed: {msg}')

            LOG.info("Stack created successfully", stage=self.stage)

        def _cancel(self) -> None:
            """
            Stop the OpenStack stack allocation and remove what has been allocated.
            """
            if self.stage.start:
                self._delete_sandbox(self.stage.allocation_request.allocation_unit)

        def update_allocation_stage(self) -> StackAllocationStage:
            """
            Update stage with current stack status from the OpenStack platform.
            """
            # TODO get stack status directly!
            stacks = self._client.list_stacks()
            stack_name = self.stage.allocation_request.allocation_unit.get_stack_name()
            if stack_name in stacks:
                sb = stacks[stack_name]
                self.stage.status = sb.stack_status
                self.stage.status_reason = sb.stack_status_reason
            else:
                self.stage.status = None
                self.stage.status_reason = None
            self.stage.save()
            return self.stage


    class CleanupStackStageHandler(StackStageHandler):
        """
        Specifies tasks needed for OpenStack stack deletion and its cancellation.
        """
        stage: StackCleanupStage
        _job_class: Type[CleanupRQJob] = CleanupRQJob

        def _execute(self) -> None:
            """
            Delete allocated stack in the OpenStack platform.
            """
            self._delete_sandbox(self.stage.cleanup_request.allocation_unit)

        def _cancel(self) -> None:
            """
            Stop the deletion of the OpenStack stack.

            INFO: Nothing to be done. Deletion is irreversible operation.
            """
            pass


    class AnsibleStageHandler(StageHandler):
        """
        Generalizes common tasks of stages executing Ansible tasks on the remote infrastructure.
        """

        def __init__(self, stage: [AnsibleCleanupStage, AnsibleAllocationStage], name: str = None):
            super().__init__(stage, name)
            self.stage = stage

        @abc.abstractmethod
        def _execute(self) -> None:
            pass

        @abc.abstractmethod
        def _cancel(self) -> None:
            pass

        def create_directory_path(self, allocation_unit: SandboxAllocationUnit):
            """
            Compose absolute path to directory for Docker container volumes.
            """
            return os.path.join(settings.KYPO_CONFIG.ansible_docker_volumes,
                                allocation_unit.get_stack_name(),
                                f'{self.stage.id}-{utils.get_simple_uuid()}')

        def check_status(self, status: dict):
            """
            Check status returned by Docker container
            and raise an exception if Ansible execution failed.
            """
            status_code = status['StatusCode']
            if status_code != 0:
                raise exceptions.AnsibleError('Ansible ID={} failed with status code \'{}\''
                                              .format(self.stage.id, status_code))


    class AllocationAnsibleStageHandler(AnsibleStageHandler):
        """
        Specifies tasks needed for Ansible execution on the remote infrastructure and its cancellation.
        """
        stage: AnsibleAllocationStage
        _job_class: Type[AllocationRQJob] = AllocationRQJob

        def __init__(self, stage: AnsibleAllocationStage, sandbox: Sandbox = None, name: str = None):
            super().__init__(stage, name)

            self.allocation_unit = stage.allocation_request_fk_many.allocation_unit
            self.directory_path = self.create_directory_path(self.allocation_unit)
            self.sandbox = sandbox

        def _execute(self) -> None:
            """
            Prepare and execute the Ansible playbooks on the remote infrastructure.
            """
            if self.sandbox is None:
                raise exceptions.AnsibleError(f'Sandbox was not provided')

            runner = AllocationAnsibleDockerRunner(self.directory_path)
            runner.prepare_ssh_dir(self.allocation_unit.pool, self.sandbox)
            runner.prepare_inventory_file(self.sandbox)

            try:
                container = runner.run_container(self.stage.repo_url, self.stage.rev)
                DockerContainer.objects.create(allocation_stage=self.stage, container_id=container.id)

                for output in container.logs(stream=True):
                    output = output.decode('utf-8')
                    output = output[:-1] if output[-1] == '\n' else output
                    AllocationAnsibleOutput.objects.create(allocation_stage=self.stage, content=output)

                status = container.wait(timeout=settings.KYPO_CONFIG.sandbox_ansible_timeout)
                container.remove()
            except (docker.errors.APIError,
                    docker.errors.DockerException,
                    requests_exceptions.ReadTimeout) as ex:
                raise exceptions.DockerError(ex)

            self.check_status(status)

        def _cancel(self) -> None:
            """
            Stop the Ansible execution.
            """
            try:
                if hasattr(self.stage, 'dockercontainer'):
                    container = self.stage.dockercontainer
                    AnsibleDockerRunner(self.directory_path).delete_container(container.container_id)
                    container.delete()
            except docker.errors.NotFound as ex:
                LOG.warning('Cancelling Ansible', exception=str(ex), stage=self.stage)


    class CleanupAnsibleStageHandler(AnsibleStageHandler):
        """
        Specifies tasks needed for resources cleanup created during the Ansible execution.
        """
        stage: CleanupStage
        _job_class: Type[CleanupRQJob] = CleanupRQJob

        def __init__(self, stage: CleanupStage):
            super().__init__(stage)

            self.allocation_unit = stage.cleanup_request_fk_many.allocation_unit
            self.directory_path = self.create_directory_path(self.allocation_unit)

        def _execute(self) -> None:
            """
            Clean up resources created during the Ansible execution.
            """
            if isinstance(self.stage, UserAnsibleCleanupStage):
                return
            runner = CleanupAnsibleDockerRunner(self.directory_path)
            runner.prepare_ssh_dir(self.allocation_unit.pool)
            runner.prepare_inventory_file(self.allocation_unit)

            allocation_request = self.allocation_unit.allocation_request
            allocation_stage = allocation_request.networkingansibleallocationstage

            try:
                container = runner.run_container(allocation_stage.repo_url, allocation_stage.rev,
                                                 ansible_cleanup=True)
                DockerContainerCleanup.objects.create(cleanup_stage=self.stage,
                                                      container_id=container.id)

                for output in container.logs(stream=True):
                    output = output.decode('utf-8')
                    output = output[:-1] if output[-1] == '\n' else output
                    CleanupAnsibleOutput.objects.create(cleanup_stage=self.stage, content=output)

                status = container.wait(timeout=settings.KYPO_CONFIG.sandbox_ansible_timeout)
                container.remove()
            except (docker.errors.APIError,
                    docker.errors.DockerException,
                    requests_exceptions.ReadTimeout) as ex:
                raise exceptions.DockerError(ex)

            self.check_status(status)

        def _cancel(self) -> None:
            """
            Stop the resources clean up.

            INFO: Nothing to be done. The clean up is irreversible operation.
            """
            pass
